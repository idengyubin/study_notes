# 第二章 处理器、内存和指令

### 2.1 8086通用寄存器

8086处理器内部有8个16位的通用寄存器，AX、BX、CX、DX、SI、DI、BP、SP

![](https://gitee.com/yanyun888/pic_bed/raw/master/20220204164714.png)

### 2.2 8086内存访问和字节序

![](https://gitee.com/yanyun888/pic_bed/raw/master/20220204170302.png)

### 2.3 程序的分段和重定位

在指令中使用绝对地址的程序是**不可重定位**的。

![](https://gitee.com/yanyun888/pic_bed/raw/master/20220204171445.png)

8086处理器在访问内存时使用了分段机制，可以借助该机制解决该问题

![](https://gitee.com/yanyun888/pic_bed/raw/master/20220204170302.png)

### 2.4 内存访问的困境

![image-20220204173311068](/Users/dengyubin/Library/Application Support/typora-user-images/image-20220204173311068.png)

### 2.5 8086内存访问的过程

逻辑地址转换为物理地址

![](https://gitee.com/yanyun888/pic_bed/raw/master/20220204173932.png)

问：为什么需要分段机制？为什么8086需要这样的分段机制

**根本原因是**8086空有20位地址线却只有16位寄存器

8086的分段机制是不同于普通的分段机制的，对于普通分段机制来说，是用来解决重定位的。对于写好的代码，确实可以安排一个可用的内存地址让处理器加载你的程序到此处(称为**绝对地址**)，出于对他人加载你的程序/你加载他人的程序的考虑，为了使你的程序在任一个可用的内存地址上加载时都可以正常执行，在编写程序时就需要使用逻辑地址（或者说是相对地址），那么使用相对地址为什么能让别人加载你的程序也能正常执行呢？因为当程序被加载时，这些程序代码内被安排好的相对地址就可以根据程序实际被加载的地址来重新计算——这就是**重定位**。

**分段机制通过段地址加上偏移地址的方式解决了重定位的问题**

x86体系的处理器刚开始时只有20根地址线，寻址寄存器是16位。我们知道16位的寄存器可以访问64K的地址空间，如果程序要想访问大于64K的内存，就需要把内存分段，每段64K，用段地址+偏移量的方式来访问，这样使20根地址线全用上，最大的寻址空间就可以到1M字节，这在当时已经是非常大的内存空间了。 物理地址=左移4位的段地址+偏移地址

